# mypy: ignore-errors
# ruff: noqa
"""
Generated by quicktype. Do not manually modify this file.
"""

from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Type, TypeVar, Union, cast

from pydantic import BaseModel

T = TypeVar("T")
EnumT = TypeVar("EnumT", bound=Enum)


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def from_str(x: Any) -> str:
    assert isinstance(x, str)
    return x


def from_int(x: Any) -> int:
    assert isinstance(x, int) and not isinstance(x, bool)
    return x


def from_bool(x: Any) -> bool:
    assert isinstance(x, bool)
    return x


def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


def from_none(x: Any) -> Any:
    assert x is None
    return x


def to_enum(c: Type[EnumT], x: Any) -> EnumT:
    assert isinstance(x, c)
    return x.value


def from_dict(f: Callable[[Any], T], x: Any) -> Dict[str, T]:
    assert isinstance(x, dict)
    return {k: f(v) for (k, v) in x.items()}


def from_float(x: Any) -> float:
    assert isinstance(x, (float, int)) and not isinstance(x, bool)
    return float(x)


def to_float(x: Any) -> float:
    assert isinstance(x, (int, float))
    return x


class FilterSettings(BaseModel):
    excludesTags: List[str]
    """The tags which the cards must *not* have to be included in search results"""

    includesTags: List[str]
    """The tags which the cards must have to be included in search results"""

    languages: List[str]
    """The language the cards have to be written in to be included in search results"""

    maximumDPI: int
    """The maximum DPI that cards can have to be included in search results"""

    maximumSize: int
    """The maximum filesize that cards can have to be included in search results"""

    minimumDPI: int
    """The minimum DPI that cards must meet to be included in search results"""

    @staticmethod
    def from_dict(obj: Any) -> "FilterSettings":
        assert isinstance(obj, dict)
        excludesTags = from_list(from_str, obj.get("excludesTags"))
        includesTags = from_list(from_str, obj.get("includesTags"))
        languages = from_list(from_str, obj.get("languages"))
        maximumDPI = from_int(obj.get("maximumDPI"))
        maximumSize = from_int(obj.get("maximumSize"))
        minimumDPI = from_int(obj.get("minimumDPI"))
        return FilterSettings(excludesTags, includesTags, languages, maximumDPI, maximumSize, minimumDPI)

    def to_dict(self) -> dict:
        result: dict = {}
        result["excludesTags"] = from_list(from_str, self.excludesTags)
        result["includesTags"] = from_list(from_str, self.includesTags)
        result["languages"] = from_list(from_str, self.languages)
        result["maximumDPI"] = from_int(self.maximumDPI)
        result["maximumSize"] = from_int(self.maximumSize)
        result["minimumDPI"] = from_int(self.minimumDPI)
        return result


class SearchTypeSettings(BaseModel):
    filterCardbacks: bool
    """Whether search settings apply to cardbacks or not"""

    fuzzySearch: bool
    """Whether fuzzy search is enabled"""

    @staticmethod
    def from_dict(obj: Any) -> "SearchTypeSettings":
        assert isinstance(obj, dict)
        filterCardbacks = from_bool(obj.get("filterCardbacks"))
        fuzzySearch = from_bool(obj.get("fuzzySearch"))
        return SearchTypeSettings(filterCardbacks, fuzzySearch)

    def to_dict(self) -> dict:
        result: dict = {}
        result["filterCardbacks"] = from_bool(self.filterCardbacks)
        result["fuzzySearch"] = from_bool(self.fuzzySearch)
        return result


class SourceSettings(BaseModel):
    sources: List[List[Union[int, bool]]]
    """The list of sources in the order they should be searched"""

    @staticmethod
    def from_dict(obj: Any) -> "SourceSettings":
        assert isinstance(obj, dict)
        sources = from_list(lambda x: from_list(lambda x: from_union([from_int, from_bool], x), x), obj.get("sources"))
        return SourceSettings(sources)

    def to_dict(self) -> dict:
        result: dict = {}
        result["sources"] = from_list(
            lambda x: from_list(lambda x: from_union([from_int, from_bool], x), x), self.sources
        )
        return result


class SearchSettings(BaseModel):
    filterSettings: FilterSettings
    searchTypeSettings: SearchTypeSettings
    sourceSettings: SourceSettings

    @staticmethod
    def from_dict(obj: Any) -> "SearchSettings":
        assert isinstance(obj, dict)
        filterSettings = FilterSettings.from_dict(obj.get("filterSettings"))
        searchTypeSettings = SearchTypeSettings.from_dict(obj.get("searchTypeSettings"))
        sourceSettings = SourceSettings.from_dict(obj.get("sourceSettings"))
        return SearchSettings(filterSettings, searchTypeSettings, sourceSettings)

    def to_dict(self) -> dict:
        result: dict = {}
        result["filterSettings"] = to_class(FilterSettings, self.filterSettings)
        result["searchTypeSettings"] = to_class(SearchTypeSettings, self.searchTypeSettings)
        result["sourceSettings"] = to_class(SourceSettings, self.sourceSettings)
        return result


class CardbacksRequest(BaseModel):
    searchSettings: SearchSettings

    @staticmethod
    def from_dict(obj: Any) -> "CardbacksRequest":
        assert isinstance(obj, dict)
        searchSettings = SearchSettings.from_dict(obj.get("searchSettings"))
        return CardbacksRequest(searchSettings)

    def to_dict(self) -> dict:
        result: dict = {}
        result["searchSettings"] = to_class(SearchSettings, self.searchSettings)
        return result


class CardbacksResponse(BaseModel):
    cardbacks: List[str]

    @staticmethod
    def from_dict(obj: Any) -> "CardbacksResponse":
        assert isinstance(obj, dict)
        cardbacks = from_list(from_str, obj.get("cardbacks"))
        return CardbacksResponse(cardbacks)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cardbacks"] = from_list(from_str, self.cardbacks)
        return result


class CardsRequest(BaseModel):
    cardIdentifiers: List[str]

    @staticmethod
    def from_dict(obj: Any) -> "CardsRequest":
        assert isinstance(obj, dict)
        cardIdentifiers = from_list(from_str, obj.get("cardIdentifiers"))
        return CardsRequest(cardIdentifiers)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cardIdentifiers"] = from_list(from_str, self.cardIdentifiers)
        return result


class CardType(str, Enum):
    CARD = "CARD"
    CARDBACK = "CARDBACK"
    TOKEN = "TOKEN"


class SourceType(str, Enum):
    AWSS3 = "AWS S3"
    GoogleDrive = "Google Drive"
    LocalFile = "Local File"


class Card(BaseModel):
    cardType: CardType
    dateCreated: str
    """Created date - formatted by backend"""

    dateModified: str
    """Modified date - formatted by backend"""

    dpi: int
    extension: str
    identifier: str
    language: str
    mediumThumbnailUrl: str
    name: str
    priority: int
    searchq: str
    size: int
    smallThumbnailUrl: str
    source: str
    sourceId: int
    sourceName: str
    sourceVerbose: str
    tags: List[str]
    sourceExternalLink: Optional[str] = None
    sourceType: Optional[SourceType] = None

    @staticmethod
    def from_dict(obj: Any) -> "Card":
        assert isinstance(obj, dict)
        cardType = CardType(obj.get("cardType"))
        dateCreated = from_str(obj.get("dateCreated"))
        dateModified = from_str(obj.get("dateModified"))
        dpi = from_int(obj.get("dpi"))
        extension = from_str(obj.get("extension"))
        identifier = from_str(obj.get("identifier"))
        language = from_str(obj.get("language"))
        mediumThumbnailUrl = from_str(obj.get("mediumThumbnailUrl"))
        name = from_str(obj.get("name"))
        priority = from_int(obj.get("priority"))
        searchq = from_str(obj.get("searchq"))
        size = from_int(obj.get("size"))
        smallThumbnailUrl = from_str(obj.get("smallThumbnailUrl"))
        source = from_str(obj.get("source"))
        sourceId = from_int(obj.get("sourceId"))
        sourceName = from_str(obj.get("sourceName"))
        sourceVerbose = from_str(obj.get("sourceVerbose"))
        tags = from_list(from_str, obj.get("tags"))
        sourceExternalLink = from_union([from_str, from_none], obj.get("sourceExternalLink"))
        sourceType = from_union([SourceType, from_none], obj.get("sourceType"))
        return Card(
            cardType,
            dateCreated,
            dateModified,
            dpi,
            extension,
            identifier,
            language,
            mediumThumbnailUrl,
            name,
            priority,
            searchq,
            size,
            smallThumbnailUrl,
            source,
            sourceId,
            sourceName,
            sourceVerbose,
            tags,
            sourceExternalLink,
            sourceType,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["cardType"] = to_enum(CardType, self.cardType)
        result["dateCreated"] = from_str(self.dateCreated)
        result["dateModified"] = from_str(self.dateModified)
        result["dpi"] = from_int(self.dpi)
        result["extension"] = from_str(self.extension)
        result["identifier"] = from_str(self.identifier)
        result["language"] = from_str(self.language)
        result["mediumThumbnailUrl"] = from_str(self.mediumThumbnailUrl)
        result["name"] = from_str(self.name)
        result["priority"] = from_int(self.priority)
        result["searchq"] = from_str(self.searchq)
        result["size"] = from_int(self.size)
        result["smallThumbnailUrl"] = from_str(self.smallThumbnailUrl)
        result["source"] = from_str(self.source)
        result["sourceId"] = from_int(self.sourceId)
        result["sourceName"] = from_str(self.sourceName)
        result["sourceVerbose"] = from_str(self.sourceVerbose)
        result["tags"] = from_list(from_str, self.tags)
        if self.sourceExternalLink is not None:
            result["sourceExternalLink"] = from_union([from_str, from_none], self.sourceExternalLink)
        if self.sourceType is not None:
            result["sourceType"] = from_union([lambda x: to_enum(SourceType, x), from_none], self.sourceType)
        return result


class CardsResponse(BaseModel):
    results: Dict[str, Card]

    @staticmethod
    def from_dict(obj: Any) -> "CardsResponse":
        assert isinstance(obj, dict)
        results = from_dict(Card.from_dict, obj.get("results"))
        return CardsResponse(results)

    def to_dict(self) -> dict:
        result: dict = {}
        result["results"] = from_dict(lambda x: to_class(Card, x), self.results)
        return result


class SourceContribution(BaseModel):
    avgdpi: str
    description: str
    name: str
    qtyCardbacks: str
    qtyCards: str
    qtyTokens: str
    size: str
    sourceType: SourceType
    externalLink: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "SourceContribution":
        assert isinstance(obj, dict)
        avgdpi = from_str(obj.get("avgdpi"))
        description = from_str(obj.get("description"))
        name = from_str(obj.get("name"))
        qtyCardbacks = from_str(obj.get("qtyCardbacks"))
        qtyCards = from_str(obj.get("qtyCards"))
        qtyTokens = from_str(obj.get("qtyTokens"))
        size = from_str(obj.get("size"))
        sourceType = SourceType(obj.get("sourceType"))
        externalLink = from_union([from_str, from_none], obj.get("externalLink"))
        return SourceContribution(
            avgdpi, description, name, qtyCardbacks, qtyCards, qtyTokens, size, sourceType, externalLink
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["avgdpi"] = from_str(self.avgdpi)
        result["description"] = from_str(self.description)
        result["name"] = from_str(self.name)
        result["qtyCardbacks"] = from_str(self.qtyCardbacks)
        result["qtyCards"] = from_str(self.qtyCards)
        result["qtyTokens"] = from_str(self.qtyTokens)
        result["size"] = from_str(self.size)
        result["sourceType"] = to_enum(SourceType, self.sourceType)
        if self.externalLink is not None:
            result["externalLink"] = from_union([from_str, from_none], self.externalLink)
        return result


class ContributionsResponse(BaseModel):
    cardCountByType: Dict[str, int]
    sources: List[SourceContribution]
    totalDatabaseSize: int

    @staticmethod
    def from_dict(obj: Any) -> "ContributionsResponse":
        assert isinstance(obj, dict)
        cardCountByType = from_dict(from_int, obj.get("cardCountByType"))
        sources = from_list(SourceContribution.from_dict, obj.get("sources"))
        totalDatabaseSize = from_int(obj.get("totalDatabaseSize"))
        return ContributionsResponse(cardCountByType, sources, totalDatabaseSize)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cardCountByType"] = from_dict(from_int, self.cardCountByType)
        result["sources"] = from_list(lambda x: to_class(SourceContribution, x), self.sources)
        result["totalDatabaseSize"] = from_int(self.totalDatabaseSize)
        return result


class DFCPairsResponse(BaseModel):
    dfcPairs: Dict[str, str]

    @staticmethod
    def from_dict(obj: Any) -> "DFCPairsResponse":
        assert isinstance(obj, dict)
        dfcPairs = from_dict(from_str, obj.get("dfcPairs"))
        return DFCPairsResponse(dfcPairs)

    def to_dict(self) -> dict:
        result: dict = {}
        result["dfcPairs"] = from_dict(from_str, self.dfcPairs)
        return result


class SearchQuery(BaseModel):
    cardType: CardType
    query: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "SearchQuery":
        assert isinstance(obj, dict)
        cardType = CardType(obj.get("cardType"))
        query = from_union([from_none, from_str], obj.get("query"))
        return SearchQuery(cardType, query)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cardType"] = to_enum(CardType, self.cardType)
        result["query"] = from_union([from_none, from_str], self.query)
        return result


class EditorSearchRequest(BaseModel):
    queries: List[SearchQuery]
    searchSettings: SearchSettings

    @staticmethod
    def from_dict(obj: Any) -> "EditorSearchRequest":
        assert isinstance(obj, dict)
        queries = from_list(SearchQuery.from_dict, obj.get("queries"))
        searchSettings = SearchSettings.from_dict(obj.get("searchSettings"))
        return EditorSearchRequest(queries, searchSettings)

    def to_dict(self) -> dict:
        result: dict = {}
        result["queries"] = from_list(lambda x: to_class(SearchQuery, x), self.queries)
        result["searchSettings"] = to_class(SearchSettings, self.searchSettings)
        return result


class EditorSearchResponse(BaseModel):
    results: Dict[str, Dict[str, List[str]]]

    @staticmethod
    def from_dict(obj: Any) -> "EditorSearchResponse":
        assert isinstance(obj, dict)
        results = from_dict(lambda x: from_dict(lambda x: from_list(from_str, x), x), obj.get("results"))
        return EditorSearchResponse(results)

    def to_dict(self) -> dict:
        result: dict = {}
        result["results"] = from_dict(lambda x: from_dict(lambda x: from_list(from_str, x), x), self.results)
        return result


class ErrorResponse(BaseModel):
    name: str
    errors: Optional[List[Dict[str, Any]]] = None
    message: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "ErrorResponse":
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        errors = from_union([lambda x: from_list(lambda x: from_dict(lambda x: x, x), x), from_none], obj.get("errors"))
        message = from_union([from_str, from_none], obj.get("message"))
        return ErrorResponse(name, errors, message)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        if self.errors is not None:
            result["errors"] = from_union(
                [lambda x: from_list(lambda x: from_dict(lambda x: x, x), x), from_none], self.errors
            )
        if self.message is not None:
            result["message"] = from_union([from_str, from_none], self.message)
        return result


class SortBy(str, Enum):
    dateCreatedAscending = "dateCreatedAscending"
    dateCreatedDescending = "dateCreatedDescending"
    dateModifiedAscending = "dateModifiedAscending"
    dateModifiedDescending = "dateModifiedDescending"
    nameAscending = "nameAscending"
    nameDescending = "nameDescending"


class ExploreSearchRequest(BaseModel):
    cardTypes: List[CardType]
    pageSize: int
    pageStart: int
    searchSettings: SearchSettings
    sortBy: SortBy
    query: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "ExploreSearchRequest":
        assert isinstance(obj, dict)
        cardTypes = from_list(CardType, obj.get("cardTypes"))
        pageSize = from_int(obj.get("pageSize"))
        pageStart = from_int(obj.get("pageStart"))
        searchSettings = SearchSettings.from_dict(obj.get("searchSettings"))
        sortBy = SortBy(obj.get("sortBy"))
        query = from_union([from_none, from_str], obj.get("query"))
        return ExploreSearchRequest(cardTypes, pageSize, pageStart, searchSettings, sortBy, query)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cardTypes"] = from_list(lambda x: to_enum(CardType, x), self.cardTypes)
        result["pageSize"] = from_int(self.pageSize)
        result["pageStart"] = from_int(self.pageStart)
        result["searchSettings"] = to_class(SearchSettings, self.searchSettings)
        result["sortBy"] = to_enum(SortBy, self.sortBy)
        result["query"] = from_union([from_none, from_str], self.query)
        return result


class ExploreSearchResponse(BaseModel):
    cards: List[Card]
    count: int

    @staticmethod
    def from_dict(obj: Any) -> "ExploreSearchResponse":
        assert isinstance(obj, dict)
        cards = from_list(Card.from_dict, obj.get("cards"))
        count = from_int(obj.get("count"))
        return ExploreSearchResponse(cards, count)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cards"] = from_list(lambda x: to_class(Card, x), self.cards)
        result["count"] = from_int(self.count)
        return result


class ImportSiteDecklistRequest(BaseModel):
    url: str

    @staticmethod
    def from_dict(obj: Any) -> "ImportSiteDecklistRequest":
        assert isinstance(obj, dict)
        url = from_str(obj.get("url"))
        return ImportSiteDecklistRequest(url)

    def to_dict(self) -> dict:
        result: dict = {}
        result["url"] = from_str(self.url)
        return result


class ImportSiteDecklistResponse(BaseModel):
    cards: str

    @staticmethod
    def from_dict(obj: Any) -> "ImportSiteDecklistResponse":
        assert isinstance(obj, dict)
        cards = from_str(obj.get("cards"))
        return ImportSiteDecklistResponse(cards)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cards"] = from_str(self.cards)
        return result


class ImportSite(BaseModel):
    name: str
    url: str

    @staticmethod
    def from_dict(obj: Any) -> "ImportSite":
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        url = from_str(obj.get("url"))
        return ImportSite(name, url)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        result["url"] = from_str(self.url)
        return result


class ImportSitesResponse(BaseModel):
    importSites: List[ImportSite]

    @staticmethod
    def from_dict(obj: Any) -> "ImportSitesResponse":
        assert isinstance(obj, dict)
        importSites = from_list(ImportSite.from_dict, obj.get("importSites"))
        return ImportSitesResponse(importSites)

    def to_dict(self) -> dict:
        result: dict = {}
        result["importSites"] = from_list(lambda x: to_class(ImportSite, x), self.importSites)
        return result


class Info(BaseModel):
    description: Optional[str] = None
    discord: Optional[str] = None
    email: Optional[str] = None
    name: Optional[str] = None
    reddit: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Info":
        assert isinstance(obj, dict)
        description = from_union([from_none, from_str], obj.get("description"))
        discord = from_union([from_none, from_str], obj.get("discord"))
        email = from_union([from_none, from_str], obj.get("email"))
        name = from_union([from_none, from_str], obj.get("name"))
        reddit = from_union([from_none, from_str], obj.get("reddit"))
        return Info(description, discord, email, name, reddit)

    def to_dict(self) -> dict:
        result: dict = {}
        result["description"] = from_union([from_none, from_str], self.description)
        result["discord"] = from_union([from_none, from_str], self.discord)
        result["email"] = from_union([from_none, from_str], self.email)
        result["name"] = from_union([from_none, from_str], self.name)
        result["reddit"] = from_union([from_none, from_str], self.reddit)
        return result


class InfoResponse(BaseModel):
    info: Info

    @staticmethod
    def from_dict(obj: Any) -> "InfoResponse":
        assert isinstance(obj, dict)
        info = Info.from_dict(obj.get("info"))
        return InfoResponse(info)

    def to_dict(self) -> dict:
        result: dict = {}
        result["info"] = to_class(Info, self.info)
        return result


class Language(BaseModel):
    code: str
    name: str

    @staticmethod
    def from_dict(obj: Any) -> "Language":
        assert isinstance(obj, dict)
        code = from_str(obj.get("code"))
        name = from_str(obj.get("name"))
        return Language(code, name)

    def to_dict(self) -> dict:
        result: dict = {}
        result["code"] = from_str(self.code)
        result["name"] = from_str(self.name)
        return result


class LanguagesResponse(BaseModel):
    languages: List[Language]

    @staticmethod
    def from_dict(obj: Any) -> "LanguagesResponse":
        assert isinstance(obj, dict)
        languages = from_list(Language.from_dict, obj.get("languages"))
        return LanguagesResponse(languages)

    def to_dict(self) -> dict:
        result: dict = {}
        result["languages"] = from_list(lambda x: to_class(Language, x), self.languages)
        return result


class Source(BaseModel):
    description: str
    key: str
    name: str
    pk: int
    """Primary key"""

    sourceType: SourceType
    externalLink: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Source":
        assert isinstance(obj, dict)
        description = from_str(obj.get("description"))
        key = from_str(obj.get("key"))
        name = from_str(obj.get("name"))
        pk = from_int(obj.get("pk"))
        sourceType = SourceType(obj.get("sourceType"))
        externalLink = from_union([from_str, from_none], obj.get("externalLink"))
        return Source(description, key, name, pk, sourceType, externalLink)

    def to_dict(self) -> dict:
        result: dict = {}
        result["description"] = from_str(self.description)
        result["key"] = from_str(self.key)
        result["name"] = from_str(self.name)
        result["pk"] = from_int(self.pk)
        result["sourceType"] = to_enum(SourceType, self.sourceType)
        if self.externalLink is not None:
            result["externalLink"] = from_union([from_str, from_none], self.externalLink)
        return result


class NewCardsFirstPage(BaseModel):
    cards: List[Card]
    hits: int
    pages: int
    source: Source

    @staticmethod
    def from_dict(obj: Any) -> "NewCardsFirstPage":
        assert isinstance(obj, dict)
        cards = from_list(Card.from_dict, obj.get("cards"))
        hits = from_int(obj.get("hits"))
        pages = from_int(obj.get("pages"))
        source = Source.from_dict(obj.get("source"))
        return NewCardsFirstPage(cards, hits, pages, source)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cards"] = from_list(lambda x: to_class(Card, x), self.cards)
        result["hits"] = from_int(self.hits)
        result["pages"] = from_int(self.pages)
        result["source"] = to_class(Source, self.source)
        return result


class NewCardsFirstPagesResponse(BaseModel):
    results: Dict[str, NewCardsFirstPage]

    @staticmethod
    def from_dict(obj: Any) -> "NewCardsFirstPagesResponse":
        assert isinstance(obj, dict)
        results = from_dict(NewCardsFirstPage.from_dict, obj.get("results"))
        return NewCardsFirstPagesResponse(results)

    def to_dict(self) -> dict:
        result: dict = {}
        result["results"] = from_dict(lambda x: to_class(NewCardsFirstPage, x), self.results)
        return result


class NewCardsPageResponse(BaseModel):
    cards: List[Card]

    @staticmethod
    def from_dict(obj: Any) -> "NewCardsPageResponse":
        assert isinstance(obj, dict)
        cards = from_list(Card.from_dict, obj.get("cards"))
        return NewCardsPageResponse(cards)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cards"] = from_list(lambda x: to_class(Card, x), self.cards)
        return result


class CampaignClass(BaseModel):
    about: str
    id: str

    @staticmethod
    def from_dict(obj: Any) -> "CampaignClass":
        assert isinstance(obj, dict)
        about = from_str(obj.get("about"))
        id = from_str(obj.get("id"))
        return CampaignClass(about, id)

    def to_dict(self) -> dict:
        result: dict = {}
        result["about"] = from_str(self.about)
        result["id"] = from_str(self.id)
        return result


class Supporter(BaseModel):
    date: str
    name: str
    tier: str
    usd: float

    @staticmethod
    def from_dict(obj: Any) -> "Supporter":
        assert isinstance(obj, dict)
        date = from_str(obj.get("date"))
        name = from_str(obj.get("name"))
        tier = from_str(obj.get("tier"))
        usd = from_float(obj.get("usd"))
        return Supporter(date, name, tier, usd)

    def to_dict(self) -> dict:
        result: dict = {}
        result["date"] = from_str(self.date)
        result["name"] = from_str(self.name)
        result["tier"] = from_str(self.tier)
        result["usd"] = to_float(self.usd)
        return result


class SupporterTier(BaseModel):
    description: str
    title: str
    usd: float

    @staticmethod
    def from_dict(obj: Any) -> "SupporterTier":
        assert isinstance(obj, dict)
        description = from_str(obj.get("description"))
        title = from_str(obj.get("title"))
        usd = from_float(obj.get("usd"))
        return SupporterTier(description, title, usd)

    def to_dict(self) -> dict:
        result: dict = {}
        result["description"] = from_str(self.description)
        result["title"] = from_str(self.title)
        result["usd"] = to_float(self.usd)
        return result


class Patreon(BaseModel):
    members: List[Supporter]
    campaign: Optional[CampaignClass] = None
    tiers: Optional[Dict[str, SupporterTier]] = None
    url: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Patreon":
        assert isinstance(obj, dict)
        members = from_list(Supporter.from_dict, obj.get("members"))
        campaign = from_union([from_none, CampaignClass.from_dict], obj.get("campaign"))
        tiers = from_union([from_none, lambda x: from_dict(SupporterTier.from_dict, x)], obj.get("tiers"))
        url = from_union([from_none, from_str], obj.get("url"))
        return Patreon(members, campaign, tiers, url)

    def to_dict(self) -> dict:
        result: dict = {}
        result["members"] = from_list(lambda x: to_class(Supporter, x), self.members)
        result["campaign"] = from_union([from_none, lambda x: to_class(CampaignClass, x)], self.campaign)
        result["tiers"] = from_union(
            [from_none, lambda x: from_dict(lambda x: to_class(SupporterTier, x), x)], self.tiers
        )
        result["url"] = from_union([from_none, from_str], self.url)
        return result


class PatreonResponse(BaseModel):
    patreon: Patreon

    @staticmethod
    def from_dict(obj: Any) -> "PatreonResponse":
        assert isinstance(obj, dict)
        patreon = Patreon.from_dict(obj.get("patreon"))
        return PatreonResponse(patreon)

    def to_dict(self) -> dict:
        result: dict = {}
        result["patreon"] = to_class(Patreon, self.patreon)
        return result


class Cards(BaseModel):
    CARD: List[Card]
    CARDBACK: List[Card]
    TOKEN: List[Card]

    @staticmethod
    def from_dict(obj: Any) -> "Cards":
        assert isinstance(obj, dict)
        CARD = from_list(Card.from_dict, obj.get("CARD"))
        CARDBACK = from_list(Card.from_dict, obj.get("CARDBACK"))
        TOKEN = from_list(Card.from_dict, obj.get("TOKEN"))
        return Cards(CARD, CARDBACK, TOKEN)

    def to_dict(self) -> dict:
        result: dict = {}
        result["CARD"] = from_list(lambda x: to_class(Card, x), self.CARD)
        result["CARDBACK"] = from_list(lambda x: to_class(Card, x), self.CARDBACK)
        result["TOKEN"] = from_list(lambda x: to_class(Card, x), self.TOKEN)
        return result


class SampleCardsResponse(BaseModel):
    cards: Cards

    @staticmethod
    def from_dict(obj: Any) -> "SampleCardsResponse":
        assert isinstance(obj, dict)
        cards = Cards.from_dict(obj.get("cards"))
        return SampleCardsResponse(cards)

    def to_dict(self) -> dict:
        result: dict = {}
        result["cards"] = to_class(Cards, self.cards)
        return result


class SearchEngineHealthResponse(BaseModel):
    online: bool

    @staticmethod
    def from_dict(obj: Any) -> "SearchEngineHealthResponse":
        assert isinstance(obj, dict)
        online = from_bool(obj.get("online"))
        return SearchEngineHealthResponse(online)

    def to_dict(self) -> dict:
        result: dict = {}
        result["online"] = from_bool(self.online)
        return result


class SourcesResponse(BaseModel):
    results: Dict[str, Source]

    @staticmethod
    def from_dict(obj: Any) -> "SourcesResponse":
        assert isinstance(obj, dict)
        results = from_dict(Source.from_dict, obj.get("results"))
        return SourcesResponse(results)

    def to_dict(self) -> dict:
        result: dict = {}
        result["results"] = from_dict(lambda x: to_class(Source, x), self.results)
        return result


class ChildElement(BaseModel):
    children: List["ChildElement"]
    name: str
    aliases: Optional[List[str]] = None
    isEnabledByDefault: Optional[bool] = None
    parent: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "ChildElement":
        assert isinstance(obj, dict)
        children = from_list(ChildElement.from_dict, obj.get("children"))
        name = from_str(obj.get("name"))
        aliases = from_union([lambda x: from_list(from_str, x), from_none], obj.get("aliases"))
        isEnabledByDefault = from_union([from_bool, from_none], obj.get("isEnabledByDefault"))
        parent = from_union([from_none, from_str], obj.get("parent"))
        return ChildElement(children, name, aliases, isEnabledByDefault, parent)

    def to_dict(self) -> dict:
        result: dict = {}
        result["children"] = from_list(lambda x: to_class(ChildElement, x), self.children)
        result["name"] = from_str(self.name)
        if self.aliases is not None:
            result["aliases"] = from_union([lambda x: from_list(from_str, x), from_none], self.aliases)
        if self.isEnabledByDefault is not None:
            result["isEnabledByDefault"] = from_union([from_bool, from_none], self.isEnabledByDefault)
        result["parent"] = from_union([from_none, from_str], self.parent)
        return result


class Tag(BaseModel):
    children: List[ChildElement]
    name: str
    aliases: Optional[List[str]] = None
    isEnabledByDefault: Optional[bool] = None
    parent: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Tag":
        assert isinstance(obj, dict)
        children = from_list(ChildElement.from_dict, obj.get("children"))
        name = from_str(obj.get("name"))
        aliases = from_union([lambda x: from_list(from_str, x), from_none], obj.get("aliases"))
        isEnabledByDefault = from_union([from_bool, from_none], obj.get("isEnabledByDefault"))
        parent = from_union([from_none, from_str], obj.get("parent"))
        return Tag(children, name, aliases, isEnabledByDefault, parent)

    def to_dict(self) -> dict:
        result: dict = {}
        result["children"] = from_list(lambda x: to_class(ChildElement, x), self.children)
        result["name"] = from_str(self.name)
        if self.aliases is not None:
            result["aliases"] = from_union([lambda x: from_list(from_str, x), from_none], self.aliases)
        if self.isEnabledByDefault is not None:
            result["isEnabledByDefault"] = from_union([from_bool, from_none], self.isEnabledByDefault)
        result["parent"] = from_union([from_none, from_str], self.parent)
        return result


class TagsResponse(BaseModel):
    tags: List[Tag]

    @staticmethod
    def from_dict(obj: Any) -> "TagsResponse":
        assert isinstance(obj, dict)
        tags = from_list(Tag.from_dict, obj.get("tags"))
        return TagsResponse(tags)

    def to_dict(self) -> dict:
        result: dict = {}
        result["tags"] = from_list(lambda x: to_class(Tag, x), self.tags)
        return result


def Campaignfromdict(s: Any) -> Optional[CampaignClass]:
    return from_union([from_none, CampaignClass.from_dict], s)


def Campaigntodict(x: Optional[CampaignClass]) -> Any:
    return from_union([from_none, lambda x: to_class(CampaignClass, x)], x)


def Cardfromdict(s: Any) -> Card:
    return Card.from_dict(s)


def Cardtodict(x: Card) -> Any:
    return to_class(Card, x)


def CardTypefromdict(s: Any) -> CardType:
    return CardType(s)


def CardTypetodict(x: CardType) -> Any:
    return to_enum(CardType, x)


def FilterSettingsfromdict(s: Any) -> FilterSettings:
    return FilterSettings.from_dict(s)


def FilterSettingstodict(x: FilterSettings) -> Any:
    return to_class(FilterSettings, x)


def ImportSitefromdict(s: Any) -> ImportSite:
    return ImportSite.from_dict(s)


def ImportSitetodict(x: ImportSite) -> Any:
    return to_class(ImportSite, x)


def Languagefromdict(s: Any) -> Language:
    return Language.from_dict(s)


def Languagetodict(x: Language) -> Any:
    return to_class(Language, x)


def NewCardsFirstPagefromdict(s: Any) -> NewCardsFirstPage:
    return NewCardsFirstPage.from_dict(s)


def NewCardsFirstPagetodict(x: NewCardsFirstPage) -> Any:
    return to_class(NewCardsFirstPage, x)


def SearchQueryfromdict(s: Any) -> SearchQuery:
    return SearchQuery.from_dict(s)


def SearchQuerytodict(x: SearchQuery) -> Any:
    return to_class(SearchQuery, x)


def SearchSettingsfromdict(s: Any) -> SearchSettings:
    return SearchSettings.from_dict(s)


def SearchSettingstodict(x: SearchSettings) -> Any:
    return to_class(SearchSettings, x)


def SearchTypeSettingsfromdict(s: Any) -> SearchTypeSettings:
    return SearchTypeSettings.from_dict(s)


def SearchTypeSettingstodict(x: SearchTypeSettings) -> Any:
    return to_class(SearchTypeSettings, x)


def SortByfromdict(s: Any) -> SortBy:
    return SortBy(s)


def SortBytodict(x: SortBy) -> Any:
    return to_enum(SortBy, x)


def Sourcefromdict(s: Any) -> Source:
    return Source.from_dict(s)


def Sourcetodict(x: Source) -> Any:
    return to_class(Source, x)


def SourceContributionfromdict(s: Any) -> SourceContribution:
    return SourceContribution.from_dict(s)


def SourceContributiontodict(x: SourceContribution) -> Any:
    return to_class(SourceContribution, x)


def SourceRowfromdict(s: Any) -> List[Union[int, bool]]:
    return from_list(lambda x: from_union([from_int, from_bool], x), s)


def SourceRowtodict(x: List[Union[int, bool]]) -> Any:
    return from_list(lambda x: from_union([from_int, from_bool], x), x)


def SourceSettingsfromdict(s: Any) -> SourceSettings:
    return SourceSettings.from_dict(s)


def SourceSettingstodict(x: SourceSettings) -> Any:
    return to_class(SourceSettings, x)


def SourceTypefromdict(s: Any) -> SourceType:
    return SourceType(s)


def SourceTypetodict(x: SourceType) -> Any:
    return to_enum(SourceType, x)


def Supporterfromdict(s: Any) -> Supporter:
    return Supporter.from_dict(s)


def Supportertodict(x: Supporter) -> Any:
    return to_class(Supporter, x)


def SupporterTierfromdict(s: Any) -> SupporterTier:
    return SupporterTier.from_dict(s)


def SupporterTiertodict(x: SupporterTier) -> Any:
    return to_class(SupporterTier, x)


def Tagfromdict(s: Any) -> Tag:
    return Tag.from_dict(s)


def Tagtodict(x: Tag) -> Any:
    return to_class(Tag, x)


def CardbacksRequestfromdict(s: Any) -> CardbacksRequest:
    return CardbacksRequest.from_dict(s)


def CardbacksRequesttodict(x: CardbacksRequest) -> Any:
    return to_class(CardbacksRequest, x)


def CardbacksResponsefromdict(s: Any) -> CardbacksResponse:
    return CardbacksResponse.from_dict(s)


def CardbacksResponsetodict(x: CardbacksResponse) -> Any:
    return to_class(CardbacksResponse, x)


def CardsRequestfromdict(s: Any) -> CardsRequest:
    return CardsRequest.from_dict(s)


def CardsRequesttodict(x: CardsRequest) -> Any:
    return to_class(CardsRequest, x)


def CardsResponsefromdict(s: Any) -> CardsResponse:
    return CardsResponse.from_dict(s)


def CardsResponsetodict(x: CardsResponse) -> Any:
    return to_class(CardsResponse, x)


def ContributionsResponsefromdict(s: Any) -> ContributionsResponse:
    return ContributionsResponse.from_dict(s)


def ContributionsResponsetodict(x: ContributionsResponse) -> Any:
    return to_class(ContributionsResponse, x)


def DFCPairsResponsefromdict(s: Any) -> DFCPairsResponse:
    return DFCPairsResponse.from_dict(s)


def DFCPairsResponsetodict(x: DFCPairsResponse) -> Any:
    return to_class(DFCPairsResponse, x)


def EditorSearchRequestfromdict(s: Any) -> EditorSearchRequest:
    return EditorSearchRequest.from_dict(s)


def EditorSearchRequesttodict(x: EditorSearchRequest) -> Any:
    return to_class(EditorSearchRequest, x)


def EditorSearchResponsefromdict(s: Any) -> EditorSearchResponse:
    return EditorSearchResponse.from_dict(s)


def EditorSearchResponsetodict(x: EditorSearchResponse) -> Any:
    return to_class(EditorSearchResponse, x)


def ErrorResponsefromdict(s: Any) -> ErrorResponse:
    return ErrorResponse.from_dict(s)


def ErrorResponsetodict(x: ErrorResponse) -> Any:
    return to_class(ErrorResponse, x)


def ExploreSearchRequestfromdict(s: Any) -> ExploreSearchRequest:
    return ExploreSearchRequest.from_dict(s)


def ExploreSearchRequesttodict(x: ExploreSearchRequest) -> Any:
    return to_class(ExploreSearchRequest, x)


def ExploreSearchResponsefromdict(s: Any) -> ExploreSearchResponse:
    return ExploreSearchResponse.from_dict(s)


def ExploreSearchResponsetodict(x: ExploreSearchResponse) -> Any:
    return to_class(ExploreSearchResponse, x)


def ImportSiteDecklistRequestfromdict(s: Any) -> ImportSiteDecklistRequest:
    return ImportSiteDecklistRequest.from_dict(s)


def ImportSiteDecklistRequesttodict(x: ImportSiteDecklistRequest) -> Any:
    return to_class(ImportSiteDecklistRequest, x)


def ImportSiteDecklistResponsefromdict(s: Any) -> ImportSiteDecklistResponse:
    return ImportSiteDecklistResponse.from_dict(s)


def ImportSiteDecklistResponsetodict(x: ImportSiteDecklistResponse) -> Any:
    return to_class(ImportSiteDecklistResponse, x)


def ImportSitesResponsefromdict(s: Any) -> ImportSitesResponse:
    return ImportSitesResponse.from_dict(s)


def ImportSitesResponsetodict(x: ImportSitesResponse) -> Any:
    return to_class(ImportSitesResponse, x)


def InfoResponsefromdict(s: Any) -> InfoResponse:
    return InfoResponse.from_dict(s)


def InfoResponsetodict(x: InfoResponse) -> Any:
    return to_class(InfoResponse, x)


def LanguagesResponsefromdict(s: Any) -> LanguagesResponse:
    return LanguagesResponse.from_dict(s)


def LanguagesResponsetodict(x: LanguagesResponse) -> Any:
    return to_class(LanguagesResponse, x)


def NewCardsFirstPagesResponsefromdict(s: Any) -> NewCardsFirstPagesResponse:
    return NewCardsFirstPagesResponse.from_dict(s)


def NewCardsFirstPagesResponsetodict(x: NewCardsFirstPagesResponse) -> Any:
    return to_class(NewCardsFirstPagesResponse, x)


def NewCardsPageResponsefromdict(s: Any) -> NewCardsPageResponse:
    return NewCardsPageResponse.from_dict(s)


def NewCardsPageResponsetodict(x: NewCardsPageResponse) -> Any:
    return to_class(NewCardsPageResponse, x)


def PatreonResponsefromdict(s: Any) -> PatreonResponse:
    return PatreonResponse.from_dict(s)


def PatreonResponsetodict(x: PatreonResponse) -> Any:
    return to_class(PatreonResponse, x)


def SampleCardsResponsefromdict(s: Any) -> SampleCardsResponse:
    return SampleCardsResponse.from_dict(s)


def SampleCardsResponsetodict(x: SampleCardsResponse) -> Any:
    return to_class(SampleCardsResponse, x)


def SearchEngineHealthResponsefromdict(s: Any) -> SearchEngineHealthResponse:
    return SearchEngineHealthResponse.from_dict(s)


def SearchEngineHealthResponsetodict(x: SearchEngineHealthResponse) -> Any:
    return to_class(SearchEngineHealthResponse, x)


def SourcesResponsefromdict(s: Any) -> SourcesResponse:
    return SourcesResponse.from_dict(s)


def SourcesResponsetodict(x: SourcesResponse) -> Any:
    return to_class(SourcesResponse, x)


def TagsResponsefromdict(s: Any) -> TagsResponse:
    return TagsResponse.from_dict(s)


def TagsResponsetodict(x: TagsResponse) -> Any:
    return to_class(TagsResponse, x)
